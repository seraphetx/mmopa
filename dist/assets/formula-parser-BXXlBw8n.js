var M=Object.defineProperty,k=(n,t,e)=>t in n?M(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,s=(n,t,e)=>(k(n,typeof t!="symbol"?t+"":t,e),e);function E(n,t,e){let r=n,i=null;for(let o of t){if(!["object","string"].includes(typeof r))throw new Error(`Cannot evaluate ${o}, property not found (from path ${e})`);if(typeof r=="object"&&!(o in r))throw new Error(`Cannot evaluate ${o}, property not found (from path ${e})`);if(typeof r=="string"&&!r.hasOwnProperty(o))throw new Error(`Cannot evaluate ${o}, property not found (from path ${e})`);i=r,r=r[o]}return typeof r=="function"&&i&&(r=r.bind(i)),r}class _{static throwIfNotNumber(t){if(typeof t=="string")throw new Error("Strings are not allowed in math operations")}}class c{static throwIfNotNumber(t){if(typeof t=="string")throw new Error("Strings are not allowed in math operations")}}class l{static createOperatorExpression(t,e,r){const i=typeof t=="string"?t:String(t.value);if(i==="^")return new b(e,r);if(["*","/"].includes(i))return new m(i,e,r);if(["+","-"].includes(i))return new w(i,e,r);if(["<",">","<=",">=","=","!="].includes(i))return new p(i,e,r);throw new Error(`Unknown operator: ${i}`)}toString(){return""}}class T extends l{constructor(t){if(super(),s(this,"innerExpression"),this.innerExpression=t,!(this.innerExpression instanceof l))throw new Error("No inner expression given for bracket expression")}evaluate(t={}){return this.innerExpression.evaluate(t)}toString(){return`(${this.innerExpression.toString()})`}}class g extends l{constructor(t,e="number"){switch(super(),s(this,"value"),s(this,"type"),this.value=Number(t),e){case"number":if(this.value=Number(t),isNaN(this.value))throw new Error("Cannot parse number: "+t);break;case"string":this.value=String(t);break;default:throw new Error("Invalid value type: "+e)}this.type=e}evaluate(){return this.value}toString(){switch(this.type){case"number":return String(this.value);case"string":return'"'+this.value+'"';default:throw new Error("Invalid type")}}}class w extends l{constructor(t,e,r){if(super(),s(this,"operator"),s(this,"left"),s(this,"right"),!["+","-"].includes(t))throw new Error(`Operator not allowed in Plus/Minus expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){const e=this.left.evaluate(t),r=this.right.evaluate(t);if(c.throwIfNotNumber(e),c.throwIfNotNumber(r),this.operator==="+")return Number(e)+Number(r);if(this.operator==="-")return Number(e)-Number(r);throw new Error("Unknown operator for PlusMinus expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}s(w,"PLUS","+"),s(w,"MINUS","-");class m extends l{constructor(t,e,r){if(super(),s(this,"operator"),s(this,"left"),s(this,"right"),!["*","/"].includes(t))throw new Error(`Operator not allowed in Multiply/Division expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){const e=this.left.evaluate(t),r=this.right.evaluate(t);if(c.throwIfNotNumber(e),c.throwIfNotNumber(r),this.operator==="*")return Number(e)*Number(r);if(this.operator==="/")return Number(e)/Number(r);throw new Error("Unknown operator for MultDiv expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}s(m,"MULT","*"),s(m,"DIV","/");class b extends l{constructor(t,e){super(),s(this,"base"),s(this,"exponent"),this.base=t,this.exponent=e}evaluate(t={}){const e=this.base.evaluate(t),r=this.exponent.evaluate(t);return c.throwIfNotNumber(e),c.throwIfNotNumber(r),Math.pow(Number(e),Number(r))}toString(){return`${this.base.toString()}^${this.exponent.toString()}`}}class p extends l{constructor(t,e,r){if(super(),s(this,"operator"),s(this,"left"),s(this,"right"),!["<",">","<=",">=","=","!="].includes(t))throw new Error(`Operator not allowed in Logical expression: ${t}`);this.operator=t,this.left=e,this.right=r}evaluate(t={}){const e=this.left.evaluate(t),r=this.right.evaluate(t);switch(this.operator){case"<":return e<r?1:0;case">":return e>r?1:0;case"<=":return e<=r?1:0;case">=":return e>=r?1:0;case"=":return e===r?1:0;case"!=":return e!==r?1:0}throw new Error("Unknown operator for Logical expression")}toString(){return`${this.left.toString()} ${this.operator} ${this.right.toString()}`}}s(p,"LT","<"),s(p,"GT",">"),s(p,"LTE","<="),s(p,"GTE",">="),s(p,"EQ","="),s(p,"NEQ","!=");class A extends l{constructor(t,e,r=null){super(),s(this,"fn"),s(this,"varPath"),s(this,"argumentExpressions"),s(this,"formulaObject"),s(this,"blacklisted"),this.fn=t??"",this.varPath=this.fn.split("."),this.argumentExpressions=e||[],this.formulaObject=r,this.blacklisted=void 0}evaluate(t={}){t=t||{};const e=this.argumentExpressions.map(i=>i.evaluate(t));try{let i=E(t,this.varPath,this.fn);if(i instanceof Function)return i.apply(this,e)}catch{}let r;try{r=E(this.formulaObject??{},this.varPath,this.fn)}catch{}if(this.formulaObject&&r instanceof Function){if(this.isBlacklisted())throw new Error("Blacklisted function called: "+this.fn);return r.apply(this.formulaObject,e)}try{const i=E(Math,this.varPath,this.fn);if(i instanceof Function)return e.forEach(o=>{_.throwIfNotNumber(o)}),i.apply(this,e)}catch{}throw new Error("Function not found: "+this.fn)}toString(){return`${this.fn}(${this.argumentExpressions.map(t=>t.toString()).join(", ")})`}isBlacklisted(){return this.blacklisted===void 0&&(this.blacklisted=L.functionBlacklist.includes(this.formulaObject?this.formulaObject[this.fn]:null)),this.blacklisted}}class P extends l{constructor(t,e=null){super(),s(this,"fullPath"),s(this,"varPath"),s(this,"formulaObject"),this.formulaObject=e,this.fullPath=t,this.varPath=t.split(".")}evaluate(t={}){let e;try{e=E(t,this.varPath,this.fullPath)}catch{}if(e===void 0&&(e=E(this.formulaObject??{},this.varPath,this.fullPath)),typeof e=="function")throw new Error(`Cannot use ${this.fullPath} as value: It is a function and not allowed as a variable value.`);return e}toString(){return`${this.varPath.join(".")}`}}var a=(n=>(n.NUMBER="NUMBER",n.VARIABLE="VARIABLE",n.OPERATOR="OPERATOR",n.LOGICAL_OPERATOR="LOGICAL_OPERATOR",n.FUNCTION="FUNCTION",n.LEFT_PAREN="LEFT_PAREN",n.RIGHT_PAREN="RIGHT_PAREN",n.COMMA="COMMA",n.STRING="STRING",n.EOF="EOF",n))(a||{});const y=class u{constructor(){s(this,"input"),s(this,"position"),this.input="",this.position=0}tokenize(t){this.input=t,this.position=0;const e=[];for(;this.position<this.input.length&&(this.skipWhitespace(),!(this.position>=this.input.length));){const r=this.nextToken(e);r&&e.push(r)}return e.push({type:"EOF",value:"",raw:"",position:this.position,length:0}),e}nextToken(t){return this.readString()||this.readLogicalOperator()||this.readNumber(t)||this.readOperator()||this.readParenthesis()||this.readComma()||this.readIdentifier()||this.throwUnexpectedChar()}skipWhitespace(){const t=this.input.slice(this.position).match(u.PATTERNS.WHITESPACE);t&&(this.position+=t[0].length)}remaining(){return this.input.slice(this.position)}readNumber(t){const e=this.position,r=this.remaining().match(u.PATTERNS.NUMBER);if(!r)return null;const i=r[0];if(i.startsWith("-")){const o=t.length>0?t[t.length-1]:null;if(!(!o||o.type==="OPERATOR"||o.type==="LOGICAL_OPERATOR"||o.type==="COMMA"||o.type==="LEFT_PAREN"))return null}return this.position+=i.length,{type:"NUMBER",value:parseFloat(i),raw:i,position:e,length:i.length}}readIdentifier(){const t=this.position,e=this.remaining();let r=e.match(u.PATTERNS.BRACKETED_IDENTIFIER);if(r){const i=r[0],o=r[1];if(o==="")throw new Error(`Empty bracketed variable at position ${t}`);if(!/^[a-zA-Z0-9_.]+$/.test(o)){const d=o.match(/[^a-zA-Z0-9_.]/),R=d?d[0]:o[0],$=t+1+o.indexOf(R);throw new Error(`Invalid character '${R}' in bracketed variable at position ${$}`)}this.position+=i.length;const f=this.position;this.skipWhitespace();const N=this.position<this.input.length&&this.input[this.position]==="(";return this.position=f,{type:N?"FUNCTION":"VARIABLE",value:o,raw:i,position:t,length:i.length}}if(r=e.match(u.PATTERNS.IDENTIFIER),r){const i=r[0],o=i;this.position+=i.length;const f=this.position;this.skipWhitespace();const N=this.position<this.input.length&&this.input[this.position]==="(";return this.position=f,{type:N?"FUNCTION":"VARIABLE",value:o,raw:i,position:t,length:i.length}}return null}readString(){const t=this.position,e=this.remaining();let r=e.match(u.PATTERNS.STRING_DOUBLE);if(r){const i=r[0],o=r[1].replace(/\\(.)/g,"$1");return this.position+=i.length,{type:"STRING",value:o,raw:i,position:t,length:i.length}}if(r=e.match(u.PATTERNS.STRING_SINGLE),r){const i=r[0],o=r[1].replace(/\\(.)/g,"$1");return this.position+=i.length,{type:"STRING",value:o,raw:i,position:t,length:i.length}}if(e.startsWith('"')||e.startsWith("'"))throw new Error(`Unterminated string at position ${t}`);return null}readOperator(){const t=this.position,e=this.remaining().match(u.PATTERNS.OPERATOR);if(!e)return null;const r=e[0];return this.position+=r.length,{type:"OPERATOR",value:r,raw:r,position:t,length:r.length}}readLogicalOperator(){const t=this.position,e=this.remaining();if(e.startsWith("!")&&!e.startsWith("!="))throw new Error(`Invalid operator '!' at position ${t}. Did you mean '!='?`);const r=e.match(u.PATTERNS.LOGICAL_OPERATOR);if(!r)return null;const i=r[0];return this.position+=i.length,{type:"LOGICAL_OPERATOR",value:i,raw:i,position:t,length:i.length}}readParenthesis(){const t=this.position,e=this.remaining();let r=e.match(u.PATTERNS.LEFT_PAREN);if(r){const i=r[0];return this.position+=i.length,{type:"LEFT_PAREN",value:i,raw:i,position:t,length:i.length}}if(r=e.match(u.PATTERNS.RIGHT_PAREN),r){const i=r[0];return this.position+=i.length,{type:"RIGHT_PAREN",value:i,raw:i,position:t,length:i.length}}return null}readComma(){const t=this.position,e=this.remaining().match(u.PATTERNS.COMMA);if(!e)return null;const r=e[0];return this.position+=r.length,{type:"COMMA",value:r,raw:r,position:t,length:r.length}}throwUnexpectedChar(){const t=this.input[this.position]||"EOF";throw new Error(`Unexpected character '${t}' at position ${this.position}`)}};s(y,"PATTERNS",{WHITESPACE:/^\s+/,NUMBER:/^-?\d+(\.\d+)?([eE][+\-]?\d+)?/,IDENTIFIER:/^[a-zA-Z_][a-zA-Z0-9_.]*/,BRACKETED_IDENTIFIER:/^\[([^\]]*)\]/,STRING_DOUBLE:/^"((?:[^"\\]|\\.)*)"/,STRING_SINGLE:/^'((?:[^'\\]|\\.)*)'/,LOGICAL_OPERATOR:/^(<=|>=|!=|<|>|=)/,OPERATOR:/^[+\-*/^]/,LEFT_PAREN:/^\(/,RIGHT_PAREN:/^\)/,COMMA:/^,/});let x=y;const O={"=":1,"!=":1,"<":1,">":1,"<=":1,">=":1,"+":2,"-":2,"*":3,"/":3,"^":4};class I{constructor(t,e){s(this,"tokens"),s(this,"current"),s(this,"formulaObject"),this.tokens=t,this.current=0,this.formulaObject=e}parse(){const t=this.parseExpression(0);if(!this.isAtEnd()){const e=this.peek();throw new Error(`Unexpected token '${e.value}' at position ${e.position}: Expected end of expression`)}return t}parseExpression(t){let e=this.parsePrimary();for(;!this.isAtEnd();){const r=this.peek();if(r.type!==a.OPERATOR&&r.type!==a.LOGICAL_OPERATOR)break;const i=this.getPrecedence(r);if(i<t)break;const o=r.value==="^"?i:i+1;this.consume();const f=this.parseExpression(o);e=l.createOperatorExpression(r,e,f)}return e}parsePrimary(){const t=this.peek();if(this.match(a.OPERATOR)&&t.value==="-"){this.consume();const e=this.parsePrimary();return new m("*",new g(-1),e)}if(this.match(a.OPERATOR)&&t.value==="+")return this.consume(),this.parsePrimary();if(this.match(a.NUMBER))return this.consume(),new g(t.value);if(this.match(a.STRING))return this.consume(),new g(t.value,"string");if(this.match(a.LEFT_PAREN))return this.parseParenthesizedExpression();if(this.match(a.VARIABLE,a.FUNCTION))return this.parseVariableOrFunction();throw new Error(`Unexpected token '${t.value}' at position ${t.position}: Expected number, variable, function, or '('`)}parseParenthesizedExpression(){const t=this.consume(a.LEFT_PAREN),e=this.parseExpression(0);if(!this.match(a.RIGHT_PAREN)){const r=this.peek();throw new Error(`Missing closing parenthesis at position ${r.position}: Expected ')' to match '(' at position ${t.position}`)}return this.consume(a.RIGHT_PAREN),new T(e)}parseVariableOrFunction(){const t=this.consume(),e=t.value;return this.match(a.LEFT_PAREN)?this.parseFunctionCall(e,t.position):(this.formulaObject.registerVariable(e),new P(e,this.formulaObject))}parseFunctionCall(t,e){const r=this.consume(a.LEFT_PAREN),i=[];if(!this.match(a.RIGHT_PAREN))do i.push(this.parseExpression(0));while(this.matchAndConsume(a.COMMA));if(!this.match(a.RIGHT_PAREN)){const o=this.peek();throw new Error(`Missing closing parenthesis for function '${t}' at position ${o.position}: Expected ')' to match '(' at position ${r.position}`)}return this.consume(a.RIGHT_PAREN),new A(t,i,this.formulaObject)}peek(){return this.tokens[this.current]}consume(t){const e=this.peek();if(t&&e.type!==t)throw new Error(`Expected ${t} at position ${e.position}, got ${e.type} ('${e.value}')`);return this.current++,e}match(...t){return t.includes(this.peek().type)}matchAndConsume(t){return this.match(t)?(this.consume(),!0):!1}isAtEnd(){return this.peek().type===a.EOF}getPrecedence(t){if(t.type===a.LOGICAL_OPERATOR){const e=t.value;return O[e]??0}if(t.type===a.OPERATOR){const e=t.value;return O[e]??0}return 0}}const v={PI:Math.PI,E:Math.E,LN2:Math.LN2,LN10:Math.LN10,LOG2E:Math.LOG2E,LOG10E:Math.LOG10E,SQRT1_2:Math.SQRT1_2,SQRT2:Math.SQRT2},h=class S{constructor(t,e={}){s(this,"formulaExpression"),s(this,"options"),s(this,"formulaStr"),s(this,"_variables"),s(this,"_memory"),this.formulaExpression=null,this.options={memoization:!1,...e},this.formulaStr="",this._variables=[],this._memory={},this.setFormula(t)}setFormula(t){return t&&(this.formulaExpression=null,this._variables=[],this._memory={},this.formulaStr=t,this.formulaExpression=this.parse(t)),this}enableMemoization(){this.options.memoization=!0}disableMemoization(){this.options.memoization=!1,this._memory={}}parse(t){const e=new x().tokenize(t);return new I(e,this).parse()}registerVariable(t){this._variables.indexOf(t)<0&&this._variables.push(t)}getVariables(){return this._variables}evaluate(t){if(t instanceof Array)return t.map(r=>this.evaluate(r));let e=this.getExpression();if(!(e instanceof l))throw new Error("No expression set: Did you init the object with a Formula?");if(this.options.memoization){let r=this.resultFromMemory(t);return r!==null||(r=e.evaluate({...v,...t}),this.storeInMemory(t,r)),r}return e.evaluate({...v,...t})}hashValues(t){return JSON.stringify(t)}resultFromMemory(t){let e=this.hashValues(t),r=this._memory[e];return r!==void 0?r:null}storeInMemory(t,e){this._memory[this.hashValues(t)]=e}getExpression(){return this.formulaExpression}getExpressionString(){return this.formulaExpression?this.formulaExpression.toString():""}static calc(t,e=null,r={}){return e=e??{},new S(t,r).evaluate(e)}ifElse(t,e,r){return t?e:r}first(...t){for(const e of t)if(e instanceof Array){let r=this.first(...e);if(r)return r}else if(e)return e;if(t.length>0){const e=t[t.length-1];return e instanceof Array?this.first(...e):e}throw new Error("first(): At least one argument is required")}};s(h,"Expression",l),s(h,"BracketExpression",T),s(h,"PowerExpression",b),s(h,"MultDivExpression",m),s(h,"PlusMinusExpression",w),s(h,"LogicalExpression",p),s(h,"ValueExpression",g),s(h,"VariableExpression",P),s(h,"FunctionExpression",A),s(h,"MATH_CONSTANTS",v),s(h,"ALLOWED_FUNCTIONS",["ifElse","first"]),s(h,"Tokenizer",x),s(h,"TokenType",a),s(h,"Parser",I),s(h,"functionBlacklist",Object.getOwnPropertyNames(h.prototype).filter(n=>h.prototype[n]instanceof Function&&!h.ALLOWED_FUNCTIONS.includes(n)).map(n=>h.prototype[n]));let L=h;const F={id:"formula-parser",name:"Formula Parser",webmcpName:"formula_parser",description:"Parse and evaluate mathematical formulas with variables. Define a formula and provide variable values to compute results.",category:"Mathematics",library:"fparser",params:[{name:"formula",type:"string",description:'The formula to evaluate (e.g., "x^2 + 2*x + 1")',required:!0},{name:"variables",type:"object",description:'Variable values as key-value pairs (e.g., {"x": 3})',required:!1,default:{}}],examples:[{input:{formula:"x^2 + 2*x + 1",variables:{x:3}},output:"16"},{input:{formula:"sin(x) * cos(y)",variables:{x:1.5708,y:0}},output:"1"},{input:{formula:"2 * PI * r",variables:{r:5}},output:"31.4159"}],execute:async n=>{const t=String(n.formula),e=n.variables??{},i=new L(t).evaluate(e);return{formula:t,variables:e,result:String(i)}}};export{F as f};
